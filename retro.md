# Milestone 6: A Retrospective
This report serves as an overview and look at some of the design decisions made alongside the implementation struggles and ways it could have been improved.

## What we Learned
This section outlines tactics and design methods we learned about, used or otherwise.

### MVC Design Approach and the Advantage of Planning
One of the biggest takeaways from this project was the advantages that came from careful planning set out in [Milestones 1](https://github.com/seng350/seng350f19-project-2-2/issues) and [2](docs/Milestone2/Milestone.md). Though not perfect, the large core of the implementation follows the initial design we developed, which in turn follows the MVC design pattern.

### What Changed and Why
The design itself went through [several changes](docs/Milestone2/assets/MVC%20M4.jpg) from Milestone 2 to 5. One of these changes was the creation of a CollageView that handled the display output of Collections and Catalogue:

<img src="docs/CollageView.png" width="500" height="270" />

These two views were initially considered to use seperate views, but this complicated and unnecessarily duplicated code as the overall functionality of them is nearly identical. This should have also led to a [reduction in the controllers](#catalogue-as-a-collection) too, however this was not implemented.

Another change was the transition to using MongoDB enforced document IDs in place of the initially crafted IDs. Initially we opted to have IDs generated by the individual models themselves when saving or storing objects in the design. While this had the advantage of creating numerically consistent pagination (books/1 is book 1, books/2 is book 2 ect) it created potential issues such as duplicated IDs, race conditions (2 users submitting a new book at the same time could end with the same id for a book), amoung others. 

## How Could the Implementation be Improved
This section provides an overview of what implemented aspects of the design we would change and the reasoning behind it.

### Client Side Rendering and AJAX Queries
One of the largest challenges this application would face if a larger scale rollout was attempted would be the optimization of the way Catalogue and Collection views are implemented. Specifically when handling pagination, as in a better visually designed app it would be likely that more books per page would be displayed (a grid layout opposed to the row layout above). As implemented, every page causes a single database query, which as no caching is implemented places potentially avoidable load on the database. An alternative to this would be having the first pageload retrieve information on several pages of books and using client side rendering to take care of pagination and display.

Beyond this it would also allow for the application to provide more consistent feedback on user actions without placing undue load on the main application. For example, submitting a report from the BookView page could display a warning style dialog indicating successful submission and not requiring page requests.

## How to Improve the Design
Asides from implementation changes to the actual application, there are some design changes that we feel should have been made but did not have the time to implement.

### Separated Backend Services API
One of the largest design decisions that would be made would be a refactor of most controllers to separate business/control logic away from the routing and rendering logic. This change provides some distinct advantages related to code modifiability and availability. These include:

- Reduced Code Coupling: Seperation of routing and authentication logic from all core service logic. This change would let features be implemented as just a feature change, without needing to consider user authentication levels as that can be determined by the controllers.
- Encapsulation: Logic is seperated and can be implemented as an interface the controller can use. This lets us have hard guarantees between the backend services use case and the controllers taking care of routings.
- Reduced Module Size: Currently, some controllers are logic heavy in determining how certain accesses to their routes are defined. Seperating backend means controllers are only containing routes to be handled and the authentication levels required to access them, then passing the request to the backend to process where necessary.

Another artifcat of this change would be the application being able to delegate logic work off of the user-facing application. Using `async/await` or a callback model, we can allow the express app to be concerned with handing and receiving data to consumers, and then perform any harder/intense computation through a different service API.

### Automated Performance Testing
One area I feel we missed on was the automation of certain areas of testing, specifically performance testing and some integration testing. Specifically this aspect should have been implemented outside of TravisCI (or triggered by TravisCI) or designed in a way that it can function as a form of regression test, allowing future developers to be able to determine if they meet the QAS defined for performance. In the example of performance testing, it would allow a test to be created that ensured load times are within target, and if they exceed it will provide feedback to developers on where the performance degredation may have been introduced.

### Catalogue as a Collection
This is a relatively minor design change that would not have a large impact on any of our QAS, but provides some good simplification and code reductions. Given the overall similarity between the views and logic behind Collections and Catalogue, it would simplify the design and controller logic to have treated the Catalogue as a Collection which contained all books. This change would entail creating a default collection that had all books in it (prefered), or having the BookModel add all books to a pre-set collection. 


